## Containerizing an Application

To containerize an application, you begin by creating your application. Not all applications do well with containerization. The more stateless and transient the application, the better. Also, remove any environmental configuration, as those can be provided using other tools, like ConfigMaps and secrets. Develop the application until you have a single build artifact which can be deployed to multiple environments without needing to be changed, using decoupled configuration instead. Many legacy applications become a series of objects and artifacts, residing among multiple containers.

Containerize an app can be as easy as:
- Create a [Dockerfile](https://docs.docker.com/engine/reference/builder/)
  - The name is important, as it must be those ten characters, beginning with a capital “D” newer versions allow a different filename to be used after -f <filename>.
- Build the container: `sudo docker build -t simpleapp`
- Verify the image:
    ```
    sudo docker images
    sudo docker run simpleapp
    ```
- Push to the repository: `sudo docker push`

While Docker has made it easy to upload images to their Hub, these images are then public and accessible to the world. A common alternative is to create a local repository and push images there.

Once you can push and pull images using the docker command, try to run a new deployment inside Kubernetes using the image. The string passed to the `--image` argument includes the repository to use, the name of the application, then the version.

Use kubectl create to test the image:
```
kubectl create deployment <Deploy-Name> --image=<repo>/<app-name>:<version>
kubectl create deployment time-date --image=10.110.186.162:5000/simpleapp:v2.2
```

Verify the Pod shows a running status and that all included containers are running as well: `​kubectl get pods`

Part of the testing may be to execute commands within the Pod. What commands are available depend on what was included in the base environment when the image was created. If you have more than one container, declare which container: `kubectl exec -i​t <Pod-Name> -- /bin/bash`

It may not make sense to recreate an entire image to add functionality like a shell or logging agent. Instead, you could add another container to the Pod, which would provide the necessary tools.

Each container in the Pod should be transient and decoupled.

Every container in a Pod shares a single IP address and namespace. Each container has equal potential access to storage given to the Pod. Kubernetes does not provide any locking, so your configuration or application should be such that containers do not have conflicting writes.

One container could be read only while the other writes. You could configure the containers to write to different directories in the volume, or the application could have built in locking. Without these protections, there would be no way to order containers writing to the storage.

There are three terms often used for multi-container pods:
- **ambassador**, used to communicate with outside resources, often outside the cluster (e.g proxy)
- **adapter**, useful to modify the data generated by the primary container
- **sidecar**,  secondary container which helps or provides a service not found in the primary application (e.g. logging).

Probes help ensure that applications are ready for traffic and healthy:
- **readinessProbe**, ensures the pod is in a halthy state and can accept incoming traffic
- **livenessProbe**, continually checks the health of a container
- **startupProbe**, useful for testing an application which takes a long time to start, in which case kubelet disables liveness and readiness checks until the application passes the test.

To test a deployment two built-in kubectl arguments are often used in combination. The first one is ``describe`` and the next would be `logs`.

You can see the details, conditions, volumes and events for an object with `describe`. The `Events` at the end of the output can be helpful during testing, as it presents a chronological and node view of cluster actions and associated messages: `kubectl describe pod test1`

A next step in testing may be to look at the output of containers within a pod: `kubectl logs test1`

In addition to pushing the image to a repository, you may want provide the image and other objects, such that they can be easily deployed. The [Helm](https://helm.sh/) package manager is the package manager for Kubernetes.

Helm uses a **chart**, or collection of YAML files to deploy one or more objects. For flexibility and dynamic installation, a `values.yaml` file is part of a chart and is often edited before deployment.

A chart can come from many locations, with [ArtifactHub](https://artifacthub.io/) becoming a centralized site to publish and find charts.
